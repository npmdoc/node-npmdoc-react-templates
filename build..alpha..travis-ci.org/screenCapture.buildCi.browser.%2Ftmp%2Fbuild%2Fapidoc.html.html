<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/wix/react-templates">react-templates (v0.6.1)</a>
</h1>
<h4>Light weight templates for react -&gt; write html get valid react code</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates">module react-templates</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.convertStyle">
            function <span class="apidocSignatureSpan">react-templates.</span>convertStyle
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.convertTemplateToReact">
            function <span class="apidocSignatureSpan">react-templates.</span>convertTemplateToReact
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.execute">
            function <span class="apidocSignatureSpan">react-templates.</span>execute
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.executeOptions">
            function <span class="apidocSignatureSpan">react-templates.</span>executeOptions
            <span class="apidocSignatureSpan">(currentOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.handleSingleFile">
            function <span class="apidocSignatureSpan">react-templates.</span>handleSingleFile
            <span class="apidocSignatureSpan">(currentOptions, filename)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>RTCodeError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>api</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>cli</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>context</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>fsUtil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>reactSupport</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>reactTemplates</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>rtStyle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>shell</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.RTCodeError">module react-templates.RTCodeError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.RTCodeError.RTCodeError">
            function <span class="apidocSignatureSpan">react-templates.</span>RTCodeError
            <span class="apidocSignatureSpan">(message, startOffset, endOffset, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.RTCodeError.getNodeLoc">
            function <span class="apidocSignatureSpan">react-templates.RTCodeError.</span>getNodeLoc
            <span class="apidocSignatureSpan">(context, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.api">module react-templates.api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.api.convertFile">
            function <span class="apidocSignatureSpan">react-templates.api.</span>convertFile
            <span class="apidocSignatureSpan">(source, target, options, context)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.api.</span>_test</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.api.</span>context</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.cli">module react-templates.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.cli.convertStyle">
            function <span class="apidocSignatureSpan">react-templates.cli.</span>convertStyle
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.cli.convertTemplateToReact">
            function <span class="apidocSignatureSpan">react-templates.cli.</span>convertTemplateToReact
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.cli.execute">
            function <span class="apidocSignatureSpan">react-templates.cli.</span>execute
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.cli.executeOptions">
            function <span class="apidocSignatureSpan">react-templates.cli.</span>executeOptions
            <span class="apidocSignatureSpan">(currentOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.cli.handleSingleFile">
            function <span class="apidocSignatureSpan">react-templates.cli.</span>handleSingleFile
            <span class="apidocSignatureSpan">(currentOptions, filename)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.cli.</span>context</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.context">module react-templates.context</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-templates.context.</span>color</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.clear">
            function <span class="apidocSignatureSpan">react-templates.context.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.error">
            function <span class="apidocSignatureSpan">react-templates.context.</span>error
            <span class="apidocSignatureSpan">(msg, file, line, column, startOffset, endOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.getMessages">
            function <span class="apidocSignatureSpan">react-templates.context.</span>getMessages
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.hasErrors">
            function <span class="apidocSignatureSpan">react-templates.context.</span>hasErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.info">
            function <span class="apidocSignatureSpan">react-templates.context.</span>info
            <span class="apidocSignatureSpan">(msg, file, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.issue">
            function <span class="apidocSignatureSpan">react-templates.context.</span>issue
            <span class="apidocSignatureSpan">(level, msg, file, line, column, startOffset, endOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.report">
            function <span class="apidocSignatureSpan">react-templates.context.</span>report
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.verbose">
            function <span class="apidocSignatureSpan">react-templates.context.</span>verbose
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.context.warn">
            function <span class="apidocSignatureSpan">react-templates.context.</span>warn
            <span class="apidocSignatureSpan">(msg, file, line, column, startOffset, endOffset)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.context.</span>MESSAGE_LEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.context.</span>messages</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.context.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-templates.context.</span>cwd</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.fsUtil">module react-templates.fsUtil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.fsUtil.createRelativeReadFileSync">
            function <span class="apidocSignatureSpan">react-templates.fsUtil.</span>createRelativeReadFileSync
            <span class="apidocSignatureSpan">(baseFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.fsUtil.isStale">
            function <span class="apidocSignatureSpan">react-templates.fsUtil.</span>isStale
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.options">module react-templates.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.options.generateHelp">
            function <span class="apidocSignatureSpan">react-templates.options.</span>generateHelp
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.options.generateHelpForOption">
            function <span class="apidocSignatureSpan">react-templates.options.</span>generateHelpForOption
            <span class="apidocSignatureSpan">(optionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.options.parse">
            function <span class="apidocSignatureSpan">react-templates.options.</span>parse
            <span class="apidocSignatureSpan">(input, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.options.parseArgv">
            function <span class="apidocSignatureSpan">react-templates.options.</span>parseArgv
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.reactSupport">module react-templates.reactSupport</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.reactSupport.shouldUseCreateElement">
            function <span class="apidocSignatureSpan">react-templates.reactSupport.</span>shouldUseCreateElement
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.reactSupport.</span>attributesMapping</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.reactSupport.</span>buildImport</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.reactSupport.</span>htmlSelfClosingTags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-templates.reactSupport.</span>templates</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-templates.reactSupport.</span>classNameProp</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.reactTemplates">module react-templates.reactTemplates</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.reactTemplates.RTCodeError">
            function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>RTCodeError
            <span class="apidocSignatureSpan">(message, startOffset, endOffset, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.reactTemplates.convertJSRTToJS">
            function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>convertJSRTToJS
            <span class="apidocSignatureSpan">(text, reportContext, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.reactTemplates.convertRT">
            function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>convertRT
            <span class="apidocSignatureSpan">(html, reportContext, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.reactTemplates.convertTemplateToReact">
            function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>convertTemplateToReact
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.reactTemplates.normalizeName">
            function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>normalizeName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.rtStyle">module react-templates.rtStyle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.rtStyle.convert">
            function <span class="apidocSignatureSpan">react-templates.rtStyle.</span>convert
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.rtStyle.convertBody">
            function <span class="apidocSignatureSpan">react-templates.rtStyle.</span>convertBody
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.shell">module react-templates.shell</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.shell.printResults">
            function <span class="apidocSignatureSpan">react-templates.shell.</span>printResults
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-templates.utils">module react-templates.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.addIfMissing">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>addIfMissing
            <span class="apidocSignatureSpan">(array, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.concatChildren">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>concatChildren
            <span class="apidocSignatureSpan">(children)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.convertText">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>convertText
            <span class="apidocSignatureSpan">(node, context, txt, normalizeWhitespaces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.isStringOnlyCode">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>isStringOnlyCode
            <span class="apidocSignatureSpan">(txt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.normalizeName">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>normalizeName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.usesScopeName">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>usesScopeName
            <span class="apidocSignatureSpan">(scopeNames, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.validate">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>validate
            <span class="apidocSignatureSpan">(options, context, reportContext, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-templates.utils.validateJS">
            function <span class="apidocSignatureSpan">react-templates.utils.</span>validateJS
            <span class="apidocSignatureSpan">(code, node, context)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates" id="apidoc.module.react-templates">module react-templates</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.convertStyle" id="apidoc.element.react-templates.convertStyle">
        function <span class="apidocSignatureSpan">react-templates.</span>convertStyle
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convert(text) {
    return templateCommonJSTemplate({ body: convertBody(text) });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.convertTemplateToReact" id="apidoc.element.react-templates.convertTemplateToReact">
        function <span class="apidocSignatureSpan">react-templates.</span>convertTemplateToReact
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertTemplateToReact(html, options) {
    var context = require('./context');
    return convertRT(html, context, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.execute" id="apidoc.element.react-templates.execute">
        function <span class="apidocSignatureSpan">react-templates.</span>execute
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function execute(args) {
    try {
        var currentOptions = options.parse(args);
        return executeOptions(currentOptions);
    } catch (error) {
        console.error(error.message);
        return 1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
grunt.registerTask('default', ['eslint:all']);
grunt.registerTask('lint', ['eslint:all']);
grunt.registerTask('test', ['tape']);

grunt.registerTask('rt', () =&gt; {
    const reactTemplates = require('./src/cli');
    const files = grunt.file.expand('playground/*.rt');
    const ret = reactTemplates.<span class="apidocCodeKeywordSpan">execute</span>({modules: 'amd', force: true, _: files
});
    return ret === 0;
});

grunt.registerTask('build', ['rt', 'browserify:pg']);
grunt.registerTask('home', ['rt', 'browserify:home']);
grunt.registerTask('pgall', ['rt', 'browserify', 'uglify', 'requirejs']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.executeOptions" id="apidoc.element.react-templates.executeOptions">
        function <span class="apidocSignatureSpan">react-templates.</span>executeOptions
        <span class="apidocSignatureSpan">(currentOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeOptions(currentOptions) {
    var ret = 0;
    var files = currentOptions._;
    context.options.format = currentOptions.format || 'stylish';

    if (currentOptions.version) {
        console.log('v' + pkg.version);
    } else if (currentOptions.help) {
        if (files.length) {
            console.log(options.generateHelpForOption(files[0]));
        } else {
            console.log(options.generateHelp());
        }
    } else if (currentOptions.listTargetVersion) {
        printVersions(currentOptions);
    } else if (files.length) {
        // console.log(files);
        // console.log(files.length);
        // const allFiles = _.flatMap(files, f =&gt; {
        //     const fp = path.resolve(context.cwd, f);
        //     if (fs.statSync(fp).isDirectory()) {
        //         // TODO: consider removing glob and simply walk the directory
        //         return glob.sync(`${fp}/**/*.rt`, {cwd: context.cwd});
        //     }
        //     return fp;
        // });
        var allFiles = _.flatMap(files, function (f) {
            return glob.sync(f, { cwd: context.cwd });
        });
        // console.log(allFiles.length);
        _.forEach(allFiles, handleSingleFile.bind(this, currentOptions));
        ret = shell.printResults(context);
    } else {
        console.log(options.generateHelp());
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.handleSingleFile" id="apidoc.element.react-templates.handleSingleFile">
        function <span class="apidocSignatureSpan">react-templates.</span>handleSingleFile
        <span class="apidocSignatureSpan">(currentOptions, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handleSingleFile(currentOptions, filename) {
    try {
        var sourceExt = path.extname(filename);
        var outputFilename = void 0;
        if (sourceExt === '.rt') {
            outputFilename = filename + (currentOptions.modules === 'typescript' ? '.ts' : '.js');
        } else if (sourceExt === '.jsrt') {
            outputFilename = filename.replace(/\.jsrt$/, '.js');
            currentOptions = _.assign({}, currentOptions, { modules: 'jsrt' });
        } else if (sourceExt === '.rts') {
            outputFilename = filename + '.js';
            currentOptions = _.assign({}, currentOptions, { modules: 'rts' });
        } else {
            context.error('invalid file, only handle rt/jsrt files', filename);
            return;
        }
        api.convertFile(filename, outputFilename, currentOptions, context);
    } catch (e) {
        context.error(e.message, filename, e.line, e.column, e.startOffset, e.endOffset);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.RTCodeError" id="apidoc.module.react-templates.RTCodeError">module react-templates.RTCodeError</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.RTCodeError.RTCodeError" id="apidoc.element.react-templates.RTCodeError.RTCodeError">
        function <span class="apidocSignatureSpan">react-templates.</span>RTCodeError
        <span class="apidocSignatureSpan">(message, startOffset, endOffset, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class RTCodeError extends Error {
    constructor(message, startOffset, endOffset, line, column) {
        super();
        Error.captureStackTrace(this, RTCodeError);
        this.name = 'RTCodeError';
        this.message = message || '';
        this.index = norm(startOffset);
        this.startOffset = norm(startOffset);
        this.endOffset = norm(endOffset);
        this.line = norm(line);
        this.column = norm(column);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.RTCodeError.getNodeLoc" id="apidoc.element.react-templates.RTCodeError.getNodeLoc">
        function <span class="apidocSignatureSpan">react-templates.RTCodeError.</span>getNodeLoc
        <span class="apidocSignatureSpan">(context, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeLoc(context, node) {
    const start = node.startIndex;
    const pos = getLine(context.html, node);
    let end;
    if (node.data) {
        end = start + node.data.length;
    } else if (node.next) { // eslint-disable-line
        end = node.next.startIndex;
    } else {
        end = context.html.length;
    }
    return {
        pos,
        start,
        end
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param options
 * @param {*} context
 * @param {CONTEXT} reportContext
 * @param node
 */
function validate(options, context, reportContext, node) {
if (node.type === 'tag' &amp;&amp; node.attribs['rt-if'] &amp;&amp; !node.attribs.key) {
    const loc = rtError.<span class="apidocCodeKeywordSpan">getNodeLoc</span>(context, node);
    reportContext.warn('rt-if without a key', options.fileName, loc.pos.line, loc.pos.col, loc.start, loc.end);
}
if (node.type === 'tag' &amp;&amp; node.attribs['rt-require'] &amp;&amp; (node.attribs.dependency || node
.attribs.as)) {
    const loc = rtError.getNodeLoc(context, node);
    reportContext.warn("'rt-require' is obsolete, use 'rt-import' instead", options.fileName, loc.
pos.line, loc.pos.col, loc.start, loc.end);
}
if (node.children) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.api" id="apidoc.module.react-templates.api">module react-templates.api</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.api.convertFile" id="apidoc.element.react-templates.api.convertFile">
        function <span class="apidocSignatureSpan">react-templates.api.</span>convertFile
        <span class="apidocSignatureSpan">(source, target, options, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertFile(source, target, options, context) {
    options = options || {};
    options.fileName = source;

    if (!options.force &amp;&amp; !fsUtil.isStale(source, target)) {
        context.verbose(`target file ${chalk.cyan(target)} is up to date, skipping`);
        return;
    }

    const html = fs.readFileSync(source).toString();
    if (path.extname(source) === '.rts') {
        const rtStyle = require('./rtStyle');
        const out = rtStyle.convert(html);
        if (!options.dryRun) {
            fs.writeFileSync(target, out);
        }
        return;
    }
    const modules = options.modules || 'none';
    const shouldAddName = modules === 'none' &amp;&amp; !options.name;
    if (shouldAddName) {
        options.name = reactTemplates.normalizeName(path.basename(source, path.extname(source))) + 'RT';
    }
    options.readFileSync = fsUtil.createRelativeReadFileSync(source);
    const js = modules === 'jsrt' ? convertJSRTToJS(html, context, options) : convertRT(html, context, options);
    if (!options.dryRun) {
        fs.writeFileSync(target, js);
    }
    if (shouldAddName) {
        delete options.name;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else if (sourceExt === '.rts') {
           outputFilename = filename + '.js';
           currentOptions = _.assign({}, currentOptions, {modules: 'rts'});
       } else {
           context.error('invalid file, only handle rt/jsrt files', filename);
           return;
       }
       api.<span class="apidocCodeKeywordSpan">convertFile</span>(filename, outputFilename, currentOptions, context);
   } catch (e) {
       context.error(e.message, filename, e.line, e.column, e.startOffset, e.endOffset);
   }
}

/**
* Executes the CLI based on an array of arguments that is passed in.
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.cli" id="apidoc.module.react-templates.cli">module react-templates.cli</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.cli.convertStyle" id="apidoc.element.react-templates.cli.convertStyle">
        function <span class="apidocSignatureSpan">react-templates.cli.</span>convertStyle
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convert(text) {
    return templateCommonJSTemplate({body: convertBody(text)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.cli.convertTemplateToReact" id="apidoc.element.react-templates.cli.convertTemplateToReact">
        function <span class="apidocSignatureSpan">react-templates.cli.</span>convertTemplateToReact
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertTemplateToReact(html, options) {
    const context = require('./context');
    return convertRT(html, context, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.cli.execute" id="apidoc.element.react-templates.cli.execute">
        function <span class="apidocSignatureSpan">react-templates.cli.</span>execute
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function execute(args) {
    try {
        const currentOptions = options.parse(args);
        return executeOptions(currentOptions);
    } catch (error) {
        console.error(error.message);
        return 1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
grunt.registerTask('default', ['eslint:all']);
grunt.registerTask('lint', ['eslint:all']);
grunt.registerTask('test', ['tape']);

grunt.registerTask('rt', () =&gt; {
    const reactTemplates = require('./src/cli');
    const files = grunt.file.expand('playground/*.rt');
    const ret = reactTemplates.<span class="apidocCodeKeywordSpan">execute</span>({modules: 'amd', force: true, _: files
});
    return ret === 0;
});

grunt.registerTask('build', ['rt', 'browserify:pg']);
grunt.registerTask('home', ['rt', 'browserify:home']);
grunt.registerTask('pgall', ['rt', 'browserify', 'uglify', 'requirejs']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.cli.executeOptions" id="apidoc.element.react-templates.cli.executeOptions">
        function <span class="apidocSignatureSpan">react-templates.cli.</span>executeOptions
        <span class="apidocSignatureSpan">(currentOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeOptions(currentOptions) {
    let ret = 0;
    const files = currentOptions._;
    context.options.format = currentOptions.format || 'stylish';

    if (currentOptions.version) {
        console.log(`v${pkg.version}`);
    } else if (currentOptions.help) {
        if (files.length) {
            console.log(options.generateHelpForOption(files[0]));
        } else {
            console.log(options.generateHelp());
        }
    } else if (currentOptions.listTargetVersion) {
        printVersions(currentOptions);
    } else if (files.length) {
        // console.log(files);
        // console.log(files.length);
        // const allFiles = _.flatMap(files, f =&gt; {
        //     const fp = path.resolve(context.cwd, f);
        //     if (fs.statSync(fp).isDirectory()) {
        //         // TODO: consider removing glob and simply walk the directory
        //         return glob.sync(`${fp}/**/*.rt`, {cwd: context.cwd});
        //     }
        //     return fp;
        // });
        const allFiles = _.flatMap(files, f =&gt; glob.sync(f, {cwd: context.cwd}));
        // console.log(allFiles.length);
        _.forEach(allFiles, handleSingleFile.bind(this, currentOptions));
        ret = shell.printResults(context);
    } else {
        console.log(options.generateHelp());
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.cli.handleSingleFile" id="apidoc.element.react-templates.cli.handleSingleFile">
        function <span class="apidocSignatureSpan">react-templates.cli.</span>handleSingleFile
        <span class="apidocSignatureSpan">(currentOptions, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handleSingleFile(currentOptions, filename) {
    try {
        const sourceExt = path.extname(filename);
        let outputFilename;
        if (sourceExt === '.rt') {
            outputFilename = filename + (currentOptions.modules === 'typescript' ? '.ts' : '.js');
        } else if (sourceExt === '.jsrt') {
            outputFilename = filename.replace(/\.jsrt$/, '.js');
            currentOptions = _.assign({}, currentOptions, {modules: 'jsrt'});
        } else if (sourceExt === '.rts') {
            outputFilename = filename + '.js';
            currentOptions = _.assign({}, currentOptions, {modules: 'rts'});
        } else {
            context.error('invalid file, only handle rt/jsrt files', filename);
            return;
        }
        api.convertFile(filename, outputFilename, currentOptions, context);
    } catch (e) {
        context.error(e.message, filename, e.line, e.column, e.startOffset, e.endOffset);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.context" id="apidoc.module.react-templates.context">module react-templates.context</a></h1>




    <h2>
        <a href="#apidoc.element.react-templates.context.clear" id="apidoc.element.react-templates.context.clear">
        function <span class="apidocSignatureSpan">react-templates.context.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clear() {
    context.messages = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.error" id="apidoc.element.react-templates.context.error">
        function <span class="apidocSignatureSpan">react-templates.context.</span>error
        <span class="apidocSignatureSpan">(msg, file, line, column, startOffset, endOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error(msg, file, line, column, startOffset, endOffset) {
    context.issue(MESSAGE_LEVEL.ERROR, msg, file, line, column, startOffset, endOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        } else if (sourceExt === '.jsrt') {
            outputFilename = filename.replace(/\.jsrt$/, '.js');
            currentOptions = _.assign({}, currentOptions, {modules: 'jsrt'});
        } else if (sourceExt === '.rts') {
            outputFilename = filename + '.js';
            currentOptions = _.assign({}, currentOptions, {modules: 'rts'});
        } else {
            context.<span class="apidocCodeKeywordSpan">error</span>('invalid file, only handle rt/jsrt files', filename
);
            return;
        }
        api.convertFile(filename, outputFilename, currentOptions, context);
    } catch (e) {
        context.error(e.message, filename, e.line, e.column, e.startOffset, e.endOffset);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.getMessages" id="apidoc.element.react-templates.context.getMessages">
        function <span class="apidocSignatureSpan">react-templates.context.</span>getMessages
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMessages() {
    return context.messages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const _ = require('lodash');

/**
 * @param {CONTEXT} context
 * @return {number}
 */
function printResults(context) {
    const warnings = context.<span class="apidocCodeKeywordSpan">getMessages</span>();
    const out = require(`./formatters/${context.options.format}`)(warnings);
    context.report(out);
    const grouped = _.groupBy(warnings, 'level');
    return grouped.ERROR ? grouped.ERROR.length : 0;
}

module.exports = {printResults};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.hasErrors" id="apidoc.element.react-templates.context.hasErrors">
        function <span class="apidocSignatureSpan">react-templates.context.</span>hasErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasErrors() {
    return _.some(context.messages, { level: MESSAGE_LEVEL.ERROR });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.info" id="apidoc.element.react-templates.context.info">
        function <span class="apidocSignatureSpan">react-templates.context.</span>info
        <span class="apidocSignatureSpan">(msg, file, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function info(msg, file, line, column) {
    context.issue(MESSAGE_LEVEL.INFO, msg, file, line, column);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.issue" id="apidoc.element.react-templates.context.issue">
        function <span class="apidocSignatureSpan">react-templates.context.</span>issue
        <span class="apidocSignatureSpan">(level, msg, file, line, column, startOffset, endOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function issue(level, msg, file, line, column, startOffset, endOffset) {
    context.messages.push({ level: level, msg: msg, file: file || null, line: norm(line), column: norm(column), index: norm(startOffset
), startOffset: norm(startOffset), endOffset: norm(endOffset) });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
verbose(msg) {
    if (context.options.verbose) {
        console.log(msg);
    }
},
info(msg, file, line, column) {
    context.<span class="apidocCodeKeywordSpan">issue</span>(MESSAGE_LEVEL.INFO, msg, file, line, column);
},
warn(msg, file, line, column, startOffset, endOffset) {
    context.issue(MESSAGE_LEVEL.WARN, msg, file, line, column, startOffset, endOffset);
},
error(msg, file, line, column, startOffset, endOffset) {
    context.issue(MESSAGE_LEVEL.ERROR, msg, file, line, column, startOffset, endOffset);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.report" id="apidoc.element.react-templates.context.report">
        function <span class="apidocSignatureSpan">react-templates.context.</span>report
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function report(msg) {
    console.log(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @param {CONTEXT} context
 * @return {number}
 */
function printResults(context) {
    const warnings = context.getMessages();
    const out = require(`./formatters/${context.options.format}`)(warnings);
    context.<span class="apidocCodeKeywordSpan">report</span>(out);
    const grouped = _.groupBy(warnings, 'level');
    return grouped.ERROR ? grouped.ERROR.length : 0;
}

module.exports = {printResults};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.verbose" id="apidoc.element.react-templates.context.verbose">
        function <span class="apidocSignatureSpan">react-templates.context.</span>verbose
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verbose(msg) {
    if (context.options.verbose) {
        console.log(msg);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {CONTEXT} context
 */
function convertFile(source, target, options, context) {
options = options || {};
options.fileName = source;

if (!options.force &amp;&amp; !fsUtil.isStale(source, target)) {
    context.<span class="apidocCodeKeywordSpan">verbose</span>(`target file ${chalk.cyan(target)} is up to date, skipping`);
    return;
}

const html = fs.readFileSync(source).toString();
if (path.extname(source) === '.rts') {
    const rtStyle = require('./rtStyle');
    const out = rtStyle.convert(html);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.context.warn" id="apidoc.element.react-templates.context.warn">
        function <span class="apidocSignatureSpan">react-templates.context.</span>warn
        <span class="apidocSignatureSpan">(msg, file, line, column, startOffset, endOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function warn(msg, file, line, column, startOffset, endOffset) {
    context.issue(MESSAGE_LEVEL.WARN, msg, file, line, column, startOffset, endOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {*} context
 * @param {CONTEXT} reportContext
 * @param node
 */
function validate(options, context, reportContext, node) {
if (node.type === 'tag' &amp;&amp; node.attribs['rt-if'] &amp;&amp; !node.attribs.key) {
    const loc = rtError.getNodeLoc(context, node);
    reportContext.<span class="apidocCodeKeywordSpan">warn</span>('rt-if without a key', options.fileName, loc.pos.line
, loc.pos.col, loc.start, loc.end);
}
if (node.type === 'tag' &amp;&amp; node.attribs['rt-require'] &amp;&amp; (node.attribs.dependency || node
.attribs.as)) {
    const loc = rtError.getNodeLoc(context, node);
    reportContext.warn("'rt-require' is obsolete, use 'rt-import' instead", options.fileName, loc.
pos.line, loc.pos.col, loc.start, loc.end);
}
if (node.children) {
    node.children.forEach(validate.bind(this, options, context, reportContext));
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.fsUtil" id="apidoc.module.react-templates.fsUtil">module react-templates.fsUtil</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.fsUtil.createRelativeReadFileSync" id="apidoc.element.react-templates.fsUtil.createRelativeReadFileSync">
        function <span class="apidocSignatureSpan">react-templates.fsUtil.</span>createRelativeReadFileSync
        <span class="apidocSignatureSpan">(baseFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRelativeReadFileSync(baseFile) {
    const basePath = path.dirname(baseFile);
    return filename =&gt; fs.readFileSync(path.resolve(basePath, filename));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}
const modules = options.modules || 'none';
const shouldAddName = modules === 'none' &amp;&amp; !options.name;
if (shouldAddName) {
    options.name = reactTemplates.normalizeName(path.basename(source, path.extname(source))) + 'RT';
}
options.readFileSync = fsUtil.<span class="apidocCodeKeywordSpan">createRelativeReadFileSync</span>(source);
const js = modules === 'jsrt' ? convertJSRTToJS(html, context, options) : convertRT(html, context, options);
if (!options.dryRun) {
    fs.writeFileSync(target, js);
}
if (shouldAddName) {
    delete options.name;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.fsUtil.isStale" id="apidoc.element.react-templates.fsUtil.isStale">
        function <span class="apidocSignatureSpan">react-templates.fsUtil.</span>isStale
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStale(source, target) {
    if (!fs.existsSync(target)) {
        return true;
    }
    const sourceTime = fs.statSync(source).mtime;
    const targetTime = fs.statSync(target).mtime;
    return sourceTime.getTime() &gt; targetTime.getTime();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Options} options
 * @param {CONTEXT} context
 */
function convertFile(source, target, options, context) {
options = options || {};
options.fileName = source;

if (!options.force &amp;&amp; !fsUtil.<span class="apidocCodeKeywordSpan">isStale</span>(source, target)) {
    context.verbose(`target file ${chalk.cyan(target)} is up to date, skipping`);
    return;
}

const html = fs.readFileSync(source).toString();
if (path.extname(source) === '.rts') {
    const rtStyle = require('./rtStyle');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.options" id="apidoc.module.react-templates.options">module react-templates.options</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.options.generateHelp" id="apidoc.element.react-templates.options.generateHelp">
        function <span class="apidocSignatureSpan">react-templates.options.</span>generateHelp
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelp = function (arg$){
  var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre,
descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen
, totalLen, initialSpace, wrapAllFull, i, wrap;
  ref$ = arg$ != null
    ? arg$
    : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;
  maxWidth = stdout != null &amp;&amp; stdout.isTTY ? stdout.columns - 1 : null;
  output = [];
  out = function(it){
    return output.push(it != null ? it : '');
  };
  if (prepend) {
    out(interpolate ? interp(prepend, interpolate) : prepend);
    out();
  }
  data = [];
  optionCount = 0;
  totalPreLen = 0;
  preLens = [];
  for (i$ = 0, len$ = (ref$ = options).length; i$ &lt; len$; ++i$) {
    item = ref$[i$];
    if (showHidden || !item.hidden) {
      if (that = item.heading) {
        data.push({
          type: 'heading',
          value: that
        });
      } else {
        pre = getPreText(item, helpStyle, maxWidth);
        descParts = [];
        if ((that = item.description) != null) {
          descParts.push(that);
        }
        if (that = item['enum']) {
          descParts.push("either: " + naturalJoin(that));
        }
        if (item['default'] &amp;&amp; !item.negateName) {
          descParts.push("default: " + item['default']);
        }
        desc = descParts.join(' - ');
        data.push({
          type: 'option',
          pre: pre,
          desc: desc,
          descLen: desc.length
        });
        preLen = pre.length;
        optionCount++;
        totalPreLen += preLen;
        preLens.push(preLen);
      }
    }
  }
  sortedPreLens = sort(preLens);
  maxPreLen = sortedPreLens[sortedPreLens.length - 1];
  preLenMean = initialIndent + totalPreLen / optionCount;
  x = optionCount &gt; 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
  for (i$ = sortedPreLens.length - 1; i$ &gt;= 0; --i$) {
    preLen = sortedPreLens[i$];
    if (preLen &lt;= x) {
      padAmount = preLen;
      break;
    }
  }
  descSepLen = descriptionSeparator.length;
  if (maxWidth != null) {
    fullWrapCount = 0;
    partialWrapCount = 0;
    for (i$ = 0, len$ = data.length; i$ &lt; len$; ++i$) {
      item = data[i$];
      if (item.type === 'option') {
        pre = item.pre, desc = item.desc, descLen = item.descLen;
        if (descLen === 0) {
          item.wrap = 'none';
        } else {
          preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
          totalLen = preLen + descLen;
          if (totalLen &gt; maxWidth) {
            if (descLen / 2.5 &gt; maxWidth - preLen) {
              fullWrapCount++;
              item.wrap = 'full';
            } else {
              partialWrapCount++;
              item.wrap = 'partial';
            }
          } else {
            item.wrap = 'none';
          }
        }
      }
    }
  }
  initialSpace = repeatString$(' ', initialIndent);
  wrapAllFull = optionCount &gt; 1 &amp;&amp; fullWrapCount + partialWrapCount * 0.5 &gt; optionCount * 0.5;
  for (i$ = 0, len$ = data.length; i$ &lt; len$; ++i$) {
    i = i$;
    item = data[i$];
    if (item.type === 'heading') {
      if (i !== 0) {
        out();
      }
      out(item.value + ":");
    } else {
      pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
      if (maxWidth != null) {
        if (wrapAllFull || wrap === 'full') {
          wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
          out(initialSpace + "" + pre + "\n" + wrap(desc));
          continue;
        } else if (wrap === 'partial') {
          wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
          out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, ''));
          continue;
        }
      }
      if (descLen === 0) {
        out(initialSpace + "" + pre);
      } else {
        out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + desc);
      }
    }
  }
  if (append) {
    out();
    out(interpola ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (currentOptions.version) {
    console.log(`v${pkg.version}`);
} else if (currentOptions.help) {
    if (files.length) {
        console.log(options.generateHelpForOption(files[0]));
    } else {
        console.log(options.<span class="apidocCodeKeywordSpan">generateHelp</span>());
    }
} else if (currentOptions.listTargetVersion) {
    printVersions(currentOptions);
} else if (files.length) {
    // console.log(files);
    // console.log(files.length);
    // const allFiles = _.flatMap(files, f =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.options.generateHelpForOption" id="apidoc.element.react-templates.options.generateHelpForOption">
        function <span class="apidocSignatureSpan">react-templates.options.</span>generateHelpForOption
        <span class="apidocSignatureSpan">(optionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelpForOption = function (optionName){
  var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString
, exampleString, examples, seperator;
  maxWidth = stdout != null &amp;&amp; stdout.isTTY ? stdout.columns - 1 : null;
  wrap = maxWidth ? wordwrap(maxWidth) : id;
  try {
    option = getOption(dasherize(optionName));
  } catch (e$) {
    e = e$;
    return e.message;
  }
  pre = getPreText(option, helpStyle);
  defaultString = option['default'] &amp;&amp; !option.negateName ? "\ndefault: " + option['default'] : '';
  restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks
 like an option.' : '';
  description = option.longDescription || option.description &amp;&amp; sentencize(option.description);
  fullDescription = description &amp;&amp; restPositionalString
    ? description + " " + restPositionalString
    : (that = description || restPositionalString) ? that : '';
  preDescription = 'description:';
  descriptionString = !fullDescription
    ? ''
    : maxWidth &amp;&amp; fullDescription.length - 1 - preDescription.length &gt; maxWidth
      ? "\n" + preDescription + "\n" + wrap(fullDescription)
      : "\n" + preDescription + " " + fullDescription;
  exampleString = (that = option.example) ? (examples = [].concat(that), examples.length &gt; 1
    ? "\nexamples:\n" + unlines(examples)
    : "\nexample: " + examples[0]) : '';
  seperator = defaultString || descriptionString || exampleString ? "\n" + repeatString$('=', pre.length) : '';
  return pre + "" + seperator + defaultString + descriptionString + exampleString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const files = currentOptions._;
context.options.format = currentOptions.format || 'stylish';

if (currentOptions.version) {
    console.log(`v${pkg.version}`);
} else if (currentOptions.help) {
    if (files.length) {
        console.log(options.<span class="apidocCodeKeywordSpan">generateHelpForOption</span>(files[0]));
    } else {
        console.log(options.generateHelp());
    }
} else if (currentOptions.listTargetVersion) {
    printVersions(currentOptions);
} else if (files.length) {
    // console.log(files);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.options.parse" id="apidoc.element.react-templates.options.parse">
        function <span class="apidocSignatureSpan">react-templates.options.</span>parse
        <span class="apidocSignatureSpan">(input, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, arg$){
  var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError
, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result
, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;
  slice = (arg$ != null
    ? arg$
    : {}).slice;
  obj = {};
  positional = [];
  restPositional = false;
  overrideRequired = false;
  prop = null;
  setValue = function(name, value){
    var opt, val, cra, e, currentType;
    opt = getOption(name);
    if (opt.boolean) {
      val = value;
    } else {
      try {
        cra = opt.concatRepeatedArrays;
        if (cra != null &amp;&amp; cra[0] &amp;&amp; cra[1].oneValuePerFlag &amp;&amp; opt.parsedType.length === 1 &amp;&amp; opt.parsedType[0].structure === 'array
') {
          val = [parseLevn(opt.parsedType[0].of, value)];
        } else {
          val = parseLevn(opt.parsedType, value);
        }
      } catch (e$) {
        e = e$;
        throw new Error("Invalid value for option '" + name + "' - expected type " + opt.type + ", received value: " + value + ".");
      }
      if (opt['enum'] &amp;&amp; !any(function(it){
        return deepIs(it, val);
      }, opt.parsedPossibilities)) {
        throw new Error("Option " + name + ": '" + val + "' not one of " + naturalJoin(opt['enum']) + ".");
      }
    }
    currentType = toString$.call(obj[name]).slice(8, -1);
    if (obj[name] != null) {
      if (opt.concatRepeatedArrays != null &amp;&amp; opt.concatRepeatedArrays[0] &amp;&amp; currentType === 'Array') {
        obj[name] = obj[name].concat(val);
      } else if (opt.mergeRepeatedObjects &amp;&amp; currentType === 'Object') {
        import$(obj[name], val);
      } else {
        obj[name] = val;
      }
    } else {
      obj[name] = val;
    }
    if (opt.restPositional) {
      restPositional = true;
    }
    if (opt.overrideRequired) {
      overrideRequired = true;
    }
  };
  setDefaults = function(){
    var name, ref$, value;
    for (name in ref$ = defaults) {
      value = ref$[name];
      if (obj[name] == null) {
        obj[name] = value;
      }
    }
  };
  checkRequired = function(){
    var i$, ref$, len$, name;
    if (overrideRequired) {
      return;
    }
    for (i$ = 0, len$ = (ref$ = required).length; i$ &lt; len$; ++i$) {
      name = ref$[i$];
      if (!obj[name]) {
        throw new Error("Option " + nameToRaw(name) + " is required.");
      }
    }
  };
  mutuallyExclusiveError = function(first, second){
    throw new Error("The options " + nameToRaw(first) + " and " + nameToRaw(second) + " are mutually exclusive - you cannot use
them at the same time.");
  };
  checkMutuallyExclusive = function(){
    var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
    rules = libOptions.mutuallyExclusive;
    if (!rules) {
      return;
    }
    for (i$ = 0, len$ = rules.length; i$ &lt; len$; ++i$) {
      rule = rules[i$];
      present = null;
      for (j$ = 0, len1$ = rule.length; j$ &lt; len1$; ++j$) {
        element = rule[j$];
        if (toString$.call(element).slice(8, -1) === 'Array') {
          for (k$ = 0, len2$ = element.length; k$ &lt; len2$; ++k$) {
            opt = element[k$];
            if (opt in obj) {
              if (present != null) {
                mutuallyExclusiveError(present, opt);
              } else {
                present = opt;
                break;
              }
            }
          }
        } else {
          if (element in obj) {
            if (present != null) {
              mutuallyExclusiveError(present, element);
            } else {
              present = element;
            }
          }
        }
      }
    }
  };
  checkDependency = function(option){
    var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
    dependsOn = option.dependsOn;
    if (!dependsOn || option.dependenciesMet) {
      return true;
    }
    type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);
    for (i$ = 0, len$ = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Executes the CLI based on an array of arguments that is passed in.
 * @param {string|Array|Object} args The arguments to process.
 * @returns {int} The exit code for the operation.
 */
function execute(args) {
    try {
        const currentOptions = options.<span class="apidocCodeKeywordSpan">parse</span>(args);
        return executeOptions(currentOptions);
    } catch (error) {
        console.error(error.message);
        return 1;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.options.parseArgv" id="apidoc.element.react-templates.options.parseArgv">
        function <span class="apidocSignatureSpan">react-templates.options.</span>parseArgv
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArgv = function (it){
  return parse(it, {
    slice: 2
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.reactSupport" id="apidoc.module.react-templates.reactSupport">module react-templates.reactSupport</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.reactSupport.shouldUseCreateElement" id="apidoc.element.react-templates.reactSupport.shouldUseCreateElement">
        function <span class="apidocSignatureSpan">react-templates.reactSupport.</span>shouldUseCreateElement
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldUseCreateElement(context) {
    switch (context.options.targetVersion) {
        case '0.11.2':
        case '0.11.1':
        case '0.11.0':
        case '0.10.0':
            return false;
        default:
            return true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function convertTagNameToConstructor(tagName, context) {
    if (context.options.native) {
        const targetSupport = reactNativeSupport[context.options.nativeTargetVersion];
        return _.includes(targetSupport.components, tagName) ? `${targetSupport.reactNative.name}.${tagName}` : tagName;
    }
    let isHtmlTag = _.includes(reactDOMSupport[context.options.targetVersion], tagName) || isCustomElement(tagName);
    if (reactSupport.<span class="apidocCodeKeywordSpan">shouldUseCreateElement</span>(context)) {
        isHtmlTag = isHtmlTag || tagName.match(/^\w+(-\w+)+$/);
        return isHtmlTag ? `'${tagName}'` : tagName;
    }
    return isHtmlTag ? `React.DOM.${tagName}` : tagName;
}

function isCustomElement(tagName) {
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.reactTemplates" id="apidoc.module.react-templates.reactTemplates">module react-templates.reactTemplates</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.reactTemplates.RTCodeError" id="apidoc.element.react-templates.reactTemplates.RTCodeError">
        function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>RTCodeError
        <span class="apidocSignatureSpan">(message, startOffset, endOffset, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class RTCodeError extends Error {
    constructor(message, startOffset, endOffset, line, column) {
        super();
        Error.captureStackTrace(this, RTCodeError);
        this.name = 'RTCodeError';
        this.message = message || '';
        this.index = norm(startOffset);
        this.startOffset = norm(startOffset);
        this.endOffset = norm(endOffset);
        this.line = norm(line);
        this.column = norm(column);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.reactTemplates.convertJSRTToJS" id="apidoc.element.react-templates.reactTemplates.convertJSRTToJS">
        function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>convertJSRTToJS
        <span class="apidocSignatureSpan">(text, reportContext, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertJSRTToJS(text, reportContext, options) {
    options = getOptions(options);
    options.modules = 'jsrt';
    const templateMatcherJSRT = /&lt;template&gt;([^]*?)&lt;\/template&gt;/gm;
    const code = text.replace(templateMatcherJSRT, (template, html) =&gt; convertRT(html, reportContext, options).replace(/;$/, ''));

    return parseJS(code, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.reactTemplates.convertRT" id="apidoc.element.react-templates.reactTemplates.convertRT">
        function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>convertRT
        <span class="apidocSignatureSpan">(html, reportContext, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertRT(html, reportContext, options) {
    options = getOptions(options);

    const context = defaultContext(html, options, reportContext);
    const body = parseAndConvertHtmlToReact(html, context);
    const injectedFunctions = context.injectedFunctions.join('\n');
    const statelessParams = context.stateless ? 'props, context' : '';
    const renderFunction = `function(${statelessParams}) { ${injectedFunctions}return ${body} }`;

    const requirePaths = _.map(context.defines, d =&gt; `"${d.moduleName}"`).join(',');
    const requireNames = _.map(context.defines, d =&gt; `${d.alias}`).join(',');
    const AMDArguments = _.map(context.defines, (d, i) =&gt; (d.member === '*' ? `${d.alias}` : `$${i}`)).join(','); //eslint-disable
-line
    const AMDSubstitutions = _.map(context.defines, (d, i) =&gt; (d.member === '*' ? null : `var ${d.alias} = $${i}.${d.member};`)).
join('\n'); //eslint-disable-line
    const buildImport = reactSupport.buildImport[options.modules] || reactSupport.buildImport.commonjs;
    const requires = _.map(context.defines, buildImport).join('\n');
    const header = options.flow ? '/* @flow */\n' : '';
    const vars = header + requires;
    const data = {
        renderFunction,
        requireNames,
        requirePaths,
        AMDArguments,
        AMDSubstitutions,
        vars,
        name: options.name
    };
    let code = templates[options.modules](data);
    if (options.modules !== 'typescript' &amp;&amp; options.modules !== 'jsrt') {
        code = parseJS(code, options);
    }
    return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.reactTemplates.convertTemplateToReact" id="apidoc.element.react-templates.reactTemplates.convertTemplateToReact">
        function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>convertTemplateToReact
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertTemplateToReact(html, options) {
    const context = require('./context');
    return convertRT(html, context, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.reactTemplates.normalizeName" id="apidoc.element.react-templates.reactTemplates.normalizeName">
        function <span class="apidocSignatureSpan">react-templates.reactTemplates.</span>normalizeName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeName(name) {
    return name.replace(/-/g, '_');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fs.writeFileSync(target, out);
    }
    return;
}
const modules = options.modules || 'none';
const shouldAddName = modules === 'none' &amp;&amp; !options.name;
if (shouldAddName) {
    options.name = reactTemplates.<span class="apidocCodeKeywordSpan">normalizeName</span>(path.basename(source, path.extname(source
))) + 'RT';
}
options.readFileSync = fsUtil.createRelativeReadFileSync(source);
const js = modules === 'jsrt' ? convertJSRTToJS(html, context, options) : convertRT(html, context, options);
if (!options.dryRun) {
    fs.writeFileSync(target, js);
}
if (shouldAddName) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.rtStyle" id="apidoc.module.react-templates.rtStyle">module react-templates.rtStyle</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.rtStyle.convert" id="apidoc.element.react-templates.rtStyle.convert">
        function <span class="apidocSignatureSpan">react-templates.rtStyle.</span>convert
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convert(text) {
    return templateCommonJSTemplate({body: convertBody(text)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    context.verbose(`target file ${chalk.cyan(target)} is up to date, skipping`);
    return;
}

const html = fs.readFileSync(source).toString();
if (path.extname(source) === '.rts') {
    const rtStyle = require('./rtStyle');
    const out = rtStyle.<span class="apidocCodeKeywordSpan">convert</span>(html);
    if (!options.dryRun) {
        fs.writeFileSync(target, out);
    }
    return;
}
const modules = options.modules || 'none';
const shouldAddName = modules === 'none' &amp;&amp; !options.name;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.rtStyle.convertBody" id="apidoc.element.react-templates.rtStyle.convertBody">
        function <span class="apidocSignatureSpan">react-templates.rtStyle.</span>convertBody
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertBody(text) {
    //source
    const obj = css.parse(text, {silent: false});
    const result = _.reduce(obj.stylesheet.rules, processRule2, {});
    return JSON.stringify(result, undefined, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.shell" id="apidoc.module.react-templates.shell">module react-templates.shell</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.shell.printResults" id="apidoc.element.react-templates.shell.printResults">
        function <span class="apidocSignatureSpan">react-templates.shell.</span>printResults
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printResults(context) {
    const warnings = context.getMessages();
    const out = require(`./formatters/${context.options.format}`)(warnings);
    context.report(out);
    const grouped = _.groupBy(warnings, 'level');
    return grouped.ERROR ? grouped.ERROR.length : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        //         return glob.sync(`${fp}/**/*.rt`, {cwd: context.cwd});
        //     }
        //     return fp;
        // });
        const allFiles = _.flatMap(files, f =&gt; glob.sync(f, {cwd: context.cwd}));
        // console.log(allFiles.length);
        _.forEach(allFiles, handleSingleFile.bind(this, currentOptions));
        ret = shell.<span class="apidocCodeKeywordSpan">printResults</span>(context);
    } else {
        console.log(options.generateHelp());
    }
    return ret;
}

function printVersions(currentOptions) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-templates.utils" id="apidoc.module.react-templates.utils">module react-templates.utils</a></h1>


    <h2>
        <a href="#apidoc.element.react-templates.utils.addIfMissing" id="apidoc.element.react-templates.utils.addIfMissing">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>addIfMissing
        <span class="apidocSignatureSpan">(array, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addIfMissing(array, obj) {
    if (!_.includes(array, obj)) {
        array.push(obj);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.concatChildren" id="apidoc.element.react-templates.utils.concatChildren">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>concatChildren
        <span class="apidocSignatureSpan">(children)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatChildren(children) {
    let res = '';
    _.forEach(children, child =&gt; {
        if (child &amp;&amp; !_.startsWith(child, ' /*')) {
            res += ',';
        }
        res += child;
    });
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const children = _.map(node.children, child =&gt; {
    const code = convertHtmlToReact(child, context);
    validateJS(code, child, context);
    return code;
});

data.children = utils.<span class="apidocCodeKeywordSpan">concatChildren</span>(children);

if (node.name === virtualNode) { //eslint-disable-line wix-editor/prefer-ternary
    data.body = `[${_.compact(children).join(',')}]`;
} else {
    data.body = _.template(getTagTemplateString(!hasNonSimpleChildren(node), reactSupport.shouldUseCreateElement(context)))(data
);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.convertText" id="apidoc.element.react-templates.utils.convertText">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>convertText
        <span class="apidocSignatureSpan">(node, context, txt, normalizeWhitespaces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertText(node, context, txt, normalizeWhitespaces) {
    function jsonText(text) {
        return JSON.stringify(normalizeWhitespaces ? normalizeHtmlWhitespace(text) : text);
    }
    let res = '';
    let first = true;
    const concatChar = node.type === 'text' ? ',' : '+';
    while (_.includes(txt, '{')) {
        const start = txt.indexOf('{');
        const pre = txt.substr(0, start);
        if (pre) {
            res += (first ? '' : concatChar) + jsonText(pre);
            first = false;
        }
        let curlyCounter = 1;
        let end = start;
        while (++end &lt; txt.length &amp;&amp; curlyCounter &gt; 0) {
            curlyCounter += curlyMap[txt.charAt(end)] || 0;
        }
        if (curlyCounter === 0) {
            const needsParens = start !== 0 || end !== txt.length - 1;
            res += (first ? '' : concatChar) + (needsParens ? '(' : '') + txt.substr(start + 1, end - start - 2) + (needsParens ? ')' : '');
            first = false;
            txt = txt.substr(end);
        } else {
            throw RTCodeError.build(context, node, `Failed to parse text '${txt}'`);
        }
    }
    if (txt) {
        res += (first ? '' : concatChar) + jsonText(txt);
    }
    if (res === '') {
        res = 'true';
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // Processing for both class and rt-class conveniently return strings that
        // represent JS expressions, each evaluating to a space-separated set of class names.
        // We can just join them with another space here.
        const existing = props[propKey] ? `${props[propKey]} + " " + ` : '';
        if (key === classSetAttr) {
            props[propKey] = existing + classSetTemplate({classSet: val});
        } else if (key === classAttr || key === reactSupport.classNameProp) {
            props[propKey] = existing + utils.<span class="apidocCodeKeywordSpan">convertText</span>(node, context, val.trim());
        }
    } else if (!_.startsWith(key, 'rt-')) {
        props[propKey] = utils.convertText(node, context, val.trim());
    }
});
_.assign(props, generateTemplateProps(node, context));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.isStringOnlyCode" id="apidoc.element.react-templates.utils.isStringOnlyCode">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>isStringOnlyCode
        <span class="apidocSignatureSpan">(txt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStringOnlyCode(txt) {
    return /^\s*\{.*}\s*$/g.test(txt);
    //txt = txt.trim();
    //return txt.length &amp;&amp; txt.charAt(0) === '{' &amp;&amp; txt.charAt(txt.length - 1) === '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function generateProps(node, context) {
const props = {};
_.forOwn(node.attribs, (val, key) =&gt; {
    const propKey = reactSupport.attributesMapping[key.toLowerCase()] || key;
    if (props.hasOwnProperty(propKey) &amp;&amp; propKey !== reactSupport.classNameProp) {
        throw RTCodeError.build(context, node, `duplicate definition of ${propKey} ${JSON.stringify(node.attribs)}`);
    }
    if (_.startsWith(key, 'on') &amp;&amp; !utils.<span class="apidocCodeKeywordSpan">isStringOnlyCode</span>(val)) {
        props[propKey] = handleEventHandler(val, context, node, key);
    } else if (key === 'style' &amp;&amp; !utils.isStringOnlyCode(val)) {
        props[propKey] = handleStyleProp(val, node, context);
    } else if (propKey === reactSupport.classNameProp) {
        // Processing for both class and rt-class conveniently return strings that
        // represent JS expressions, each evaluating to a space-separated set of class names.
        // We can just join them with another space here.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.normalizeName" id="apidoc.element.react-templates.utils.normalizeName">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>normalizeName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeName(name) {
    return name.replace(/-/g, '_');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fs.writeFileSync(target, out);
    }
    return;
}
const modules = options.modules || 'none';
const shouldAddName = modules === 'none' &amp;&amp; !options.name;
if (shouldAddName) {
    options.name = reactTemplates.<span class="apidocCodeKeywordSpan">normalizeName</span>(path.basename(source, path.extname(source
))) + 'RT';
}
options.readFileSync = fsUtil.createRelativeReadFileSync(source);
const js = modules === 'jsrt' ? convertJSRTToJS(html, context, options) : convertRT(html, context, options);
if (!options.dryRun) {
    fs.writeFileSync(target, js);
}
if (shouldAddName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.usesScopeName" id="apidoc.element.react-templates.utils.usesScopeName">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>usesScopeName
        <span class="apidocSignatureSpan">(scopeNames, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function usesScopeName(scopeNames, node) {
    function usesScope(root) {
        return usesScopeName(scopeNames, root);
    }
    if (_.isEmpty(scopeNames)) {
        return false;
    }
    // rt-if="x"
    if (node.type === 'Identifier') {
        return _.includes(scopeNames, node.name);
    }
    // rt-if="e({key1: value1})"
    if (node.type === 'Property') {
        return usesScope(node.value);
    }
    // rt-if="e.x" or rt-if="e1[e2]"
    if (node.type === 'MemberExpression') {
        return node.computed ? usesScope(node.object) || usesScope(node.property) : usesScope(node.object);
    }
    // rt-if="!e"
    if (node.type === 'UnaryExpression') {
        return usesScope(node.argument);
    }
    // rt-if="e1 || e2" or rt-if="e1 | e2"
    if (node.type === 'LogicalExpression' || node.type === 'BinaryExpression') {
        return usesScope(node.left) || usesScope(node.right);
    }
    // rt-if="e1(e2, ... eN)"
    if (node.type === 'CallExpression') {
        return usesScope(node.callee) || _.some(node.arguments, usesScope);
    }
    // rt-if="f({e1: e2})"
    if (node.type === 'ObjectExpression') {
        return _.some(node.properties, usesScope);
    }
    // rt-if="e1[e2]"
    if (node.type === 'ArrayExpression') {
        return _.some(node.elements, usesScope);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    try {
        ifAttributeTree = esprima.parse(node.attribs[ifAttr]);
    } catch (e) {
        throw new RTCodeError(e.message, e.index, -1);
    }
    if (ifAttributeTree &amp;&amp; ifAttributeTree.body &amp;&amp; ifAttributeTree.body.length === 1 &amp;&amp; ifAttributeTree
.body[0].type === 'ExpressionStatement') {
        // make sure that rt-if does not use an inner mapping
        if (ifAttributeTree.body[0].expression &amp;&amp; utils.<span class="apidocCodeKeywordSpan">usesScopeName</span>(innerMappingKeys
, ifAttributeTree.body[0].expression)) {
            throw RTCodeError.buildFormat(context, node, "invalid scope mapping used in if part '%s'", node.
attribs[ifAttr]);
        }
    } else {
        throw RTCodeError.buildFormat(context, node, "invalid if part '%s'", node.attribs[ifAttr]);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.validate" id="apidoc.element.react-templates.utils.validate">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>validate
        <span class="apidocSignatureSpan">(options, context, reportContext, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(options, context, reportContext, node) {
    if (node.type === 'tag' &amp;&amp; node.attribs['rt-if'] &amp;&amp; !node.attribs.key) {
        const loc = rtError.getNodeLoc(context, node);
        reportContext.warn('rt-if without a key', options.fileName, loc.pos.line, loc.pos.col, loc.start, loc.end);
    }
    if (node.type === 'tag' &amp;&amp; node.attribs['rt-require'] &amp;&amp; (node.attribs.dependency || node.attribs.as)) {
        const loc = rtError.getNodeLoc(context, node);
        reportContext.warn("'rt-require' is obsolete, use 'rt-import' instead", options.fileName, loc.pos.line, loc.pos.col, loc
.start, loc.end);
    }
    if (node.children) {
        node.children.forEach(validate.bind(this, options, context, reportContext));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function parseAndConvertHtmlToReact(html, context) {
const rootNode = cheerio.load(html, {
    lowerCaseTags: false,
    lowerCaseAttributeNames: false,
    xmlMode: true,
    withStartIndices: true
});
utils.<span class="apidocCodeKeywordSpan">validate</span>(context.options, context, context.reportContext, rootNode.root()[0]);
let rootTags = _.filter(rootNode.root()[0].children, {type: 'tag'});
rootTags = handleSelfClosingHtmlTags(rootTags);
if (!rootTags || rootTags.length === 0) {
    throw new RTCodeError('Document should have a root element');
}
let firstTag = null;
_.forEach(rootTags, tag =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-templates.utils.validateJS" id="apidoc.element.react-templates.utils.validateJS">
        function <span class="apidocSignatureSpan">react-templates.utils.</span>validateJS
        <span class="apidocSignatureSpan">(code, node, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateJS(code, node, context) {
    try {
        esprima.parse(code);
    } catch (e) {
        throw RTCodeError.build(context, node, e.description);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>